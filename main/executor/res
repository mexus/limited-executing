Checking executor.cpp...


##file ../logxx/logxx.h
1:
|
9:
10: namespace logxx {
11:
|
20:
21: class Log {
22: public:
23: Log ( const std :: string & label@1 = std :: string ( ) ) ;
24: Log ( const Log & , const std :: string & label@2 , bool inheritLevel@3 = true ) ;
25: virtual ~ Log ( ) ;
26:
27: void OverrideLogLevel ( ) ;
28: void OverrideLogLevel ( int ) ;
29: static void SetLogLevel ( int ) ;
30:
31: void OverrideStream ( ) ;
32: void OverrideStream@4 ( const std :: shared_ptr < std :: ostream > & ) ;
33: void OverrideStream@4 ( const std :: string & fileName@5 ) ;
34: static void SetStream@6 ( std :: ostream & ) ;
35:
36: template < class . . . Args >
37: std :: ostream & operator() ( LogLevel , Args . . . args ) ;
38:
39: static std :: ostream & endl@7 ( std :: ostream & ) ;
40: private:
41: static std :: mutex lock@8 ;
42: const static std :: map < LogLevel , std :: string > levelMessages@9 ;
43:
44: static std :: ostream cnull@10 ; static std :: ostream * defaultStream@11 ;
45: std :: shared_ptr < std :: ostream > overrideStream@12 ;
46:
47: std :: string label@13 ;
48:
49: static int globalLogLevel@14 ;
50: std :: shared_ptr < LogLevel > overrideLogLevel@15 ;
51:
52: void AddLabel ( const std :: string & newLabel@16 ) ;
53: int GetLogLevel ( ) const ;
54: std :: ostream & GetStream ( ) ;
55: template < class T , class . . . Args >
56: std :: ostream & Print ( std :: ostream & , T t@17 , Args . . . args ) const ;
57: std :: ostream & Print ( std :: ostream & ) const ;
58: } ;
59:
60: std :: ostream & endl@18 ( std :: ostream & ) ;
61: void SetLogLevel ( int ) ;
62: void SetStream@19 ( std :: ostream & ) ;
63:
64: }

##file ../logxx/logxx.tcc
1:
|
6:
7: namespace logxx {
8:
9: template < class . . . Args >
10: std :: ostream & Log :: operator() ( LogLevel level@20 , Args . . . args ) {
11: if ( level@20 >= GetLogLevel ( ) ) {
12: lock@8 . lock ( ) ;
13: auto & stream@21 = GetStream ( ) ;
14: auto & levelMessage@22 = levelMessages@9 . at ( level@20 ) ;
15: if ( label@13 . empty ( ) ) {
16: return Print ( stream@21 , levelMessage@22 , args . . . ) ; }
17: else {
18: return Print ( stream@21 , levelMessage@22 , label@13 , args . . . ) ; }
19: } else {
20: return cnull@10 ; }
21: }
22:
23: template < class T , class . . . Args >
24: std :: ostream & Log :: Print ( std :: ostream & s@23 , T t@24 , Args . . . args ) const {
25: s@23 << "[" << t@24 << "] " ;
26: return Print ( s@23 , args . . . ) ;
27: }
28:
29: }

##file ../server/server.h
1:
|
13:
14: class Server {
15: public:
16: Server ( int id@25 , int limit@26 ) ;
17: virtual ~ Server ( ) ;
18:
19: void UpdateLimit ( int newLimit@27 ) ;
20:
21: bool TryOccupy ( ) ;
22: void Release ( ) ;
23:
24: int InUse ( ) ;
25:
26: const int id@28 ;
27: private:
28: int limit@29 ;
29: int inUse@30 ;
30: std :: mutex access@31 ;
31: logxx :: Log cLog@32 ;
32: } ;

##file ../task/task.h
1:
|
12:
13: class Task {
14: public:
15: Task ( int id@33 , const std :: shared_ptr < Server > & ) ;
16: virtual ~ Task ( ) ;
17:
18: bool TryOccupyServer ( ) ;
19:
20: const int id@34 ;
21: protected:
22: bool serverOccupied@35 ; serverOccupied@35 = false ;
23: std :: shared_ptr < Server > server@36 ;
24: logxx :: Log cLog@37 ;
25: } ;

##file ../task/tasks_pool.h
1:
|
14:
15: class TasksPool {
16: public:
17: TasksPool ( ) ;
18: virtual ~ TasksPool ( ) ;
19:
20: std :: unique_ptr < Task > GetTask ( ) ;
21: bool LoadTasks ( ) ;
22: bool IsEmpty ( ) ;
23:
24: protected:
25: static logxx :: Log cLog@38 ;
26: std :: vector < std :: unique_ptr < Task > > scheduledTasks@39 ;
27: std :: mutex dataLock@40 ;
28:
29: virtual bool SingleThreadLoadTasks ( ) = 0 ;
30: } ;

##file ../threadxx/threadxx.h
1:
|
8:
9: class Thread {
10: public:
11: Thread ( int id@41 ) ;
12: virtual ~ Thread ( ) ;
13:
14: virtual bool Start ( ) ;
15: virtual void Join ( ) ;
16: virtual void Interrupt ( ) ;
17:
18: const int id@42 ;
19: protected:
20: virtual void Run ( ) ;
21: std :: atomic_bool interrupted@43 ;
22: std :: unique_ptr < std :: thread > thread@44 ;
23: logxx :: Log cLog@45 ;
24:
25: private:
26: void JoinWOCheck ( ) ;
27: void MakeThread ( ) ;
28: void WaitForStart ( ) ;
29:
30: std :: mutex threadExecuteMutex@46 ;
31: std :: condition_variable threadCV@47 ;
32: bool threadReadyToStart@48 ; threadReadyToStart@48 = false ;
33: bool threadStarted@49 ; threadStarted@49 = false ;
34:
35: } ;

##file executor.h
1:
|
7:
8: class Executor : public Thread {
9: public:
10: Executor ( int id@50 ) ;
11: virtual ~ Executor ( ) ;
12:
13: void SetTasksPool@51 ( TasksPool * ) ;
14: protected:
15: logxx :: Log cLog@52 ;
16: TasksPool * tasksPool@53 ; tasksPool@53 = 0 ;
17: const static std :: time_t waitOnNullTask@54 = 15 ;
18: const static std :: time_t waitOnEndTask@55 = 2 ;
19:
20: virtual void Run ( ) ;
21: virtual bool RunTask ( std :: unique_ptr < Task > & ) = 0 ;
22: } ;

##file executor.cpp
1:
|
10:
11: const std :: time_t Executor :: waitOnNullTask ;
12: const std :: time_t Executor :: waitOnEndTask ;
13:
14: Executor :: Executor ( int id@56 ) : Thread ( id@56 ) , cLog@52 ( "Executor #" + std :: to_string ( id@56 ) ) {
15: }
16:
17: Executor :: ~ Executor ( ) {
18: }
19:
20: void Executor :: SetTasksPool ( TasksPool * p@57 ) {
21: tasksPool@53 = p@57 ;
22: }
23:
24: void Executor :: Run ( ) {
25: $logxx :: $Log $log@58 ( $cLog@52 , "Run" ) ;
26: while ( ! interrupted ) {
27: auto task@59 ; task@59 = tasksPool@53 . GetTask ( ) ;
28: if ( task@59 ) {
29: log@58 ( 0 ) << logxx :: endl ;
30: 0 << "Starting task #" << task@59 . id@60 << logxx :: endl ;
31: bool res@61 ; res@61 = RunTask ( task@59 ) ;
32: auto & s@62 = 0 << "Task #" << task@59 . id@60 << " " ;
33: if ( res@61 ) {
34: s@62 << "successfully done" ; }
35: else {
36: s@62 << "failed" ; }
37: s@62 << logxx :: endl ;
38: std :: this_thread :: sleep_for ( std :: chrono :: seconds ( waitOnEndTask@55 ) ) ;
39: } else {
40: std :: this_thread :: sleep_for ( std :: chrono :: seconds ( waitOnNullTask@54 ) ) ; }
41: }
42: }



##AST
 Log const (
 Log const (
 Log (
 OverrideLogLevel (
 OverrideLogLevel int (
 SetLogLevel int (
 OverrideStream (
 OverrideStream const (
 OverrideStream const (
 SetStream std ostream :: & (
 operator() class . . Args . std ostream :: > LogLevel Args . . args . , ( &
 endl std ostream :: std ostream :: & ( &
 std mutex ::
 std map :: LogLevel < std string :: levelMessages > ,
 std ostream ::
 std ostream :: defaultStream *
 std shared_ptr :: std ostream :: < overrideStream >
 std string ::
 std shared_ptr :: LogLevel < overrideLogLevel >
 AddLabel const (
 GetLogLevel (
 std ostream :: GetStream ( &
 Print class . . Args . std ostream :: > std ostream :: & T , ( &
 Print std ostream :: std ostream :: & ( &
 endl std ostream :: std ostream :: & ( &
 SetLogLevel int (
 SetStream std ostream :: & (
 class . . Args . std ostream :: > Log operator() LogLevel ( :: &
 if level GetLogLevel ( >= (
 lock lock ( .
 stream GetStream ( =
 levelMessage levelMessages at level ( . =
 if label empty ( . (
 Print stream levelMessage , args . . . , ( return
 Print stream levelMessage , label , args . . . , ( return
 cnull return
 class . . Args . std ostream :: > Log Print std ostream :: s & T , ( :: &
 Print s args . . . , ( return
 Server int (
 Server (
 UpdateLimit int (
 TryOccupy (
 Release (
 InUse (
 std mutex ::
 logxx Log ::
 Task int (
 Task (
 TryOccupyServer (
 serverOccupied false =
 std shared_ptr :: Server < server >
 logxx Log ::
 TasksPool (
 TasksPool (
 std unique_ptr :: Task < GetTask ( >
 LoadTasks (
 IsEmpty (
 logxx Log ::
 std vector :: std unique_ptr :: < Task < > scheduledTasks >
 std mutex ::
 SingleThreadLoadTasks ( 0 =
 Thread int (
 Thread (
 Start (
 Join (
 Interrupt (
 Run (
 std atomic_bool ::
 std unique_ptr :: std thread :: < thread >
 logxx Log ::
 JoinWOCheck (
 MakeThread (
 WaitForStart (
 std mutex ::
 std condition_variable ::
 threadReadyToStart false =
 threadStarted false =
 Executor int (
 Executor (
 SetTasksPool TasksPool (
 logxx Log ::
 tasksPool 0 =
 std time_t ::
 std time_t ::
 Run (
 RunTask std unique_ptr :: Task < & > ( 0 =
 std time_t ::
 std time_t ::
 Executor Executor int ( ::
 Executor Executor ( ~ ::
 Executor SetTasksPool TasksPool p * ( ::
 tasksPool p =
 Executor Run ( ::
 logxx Log ::
 while interrupted ! (
 task tasksPool GetTask ( . =
 if task (
 log 0 ( logxx endl :: <<
 task id . logxx endl :: <<
 res RunTask task ( =
 s 0 "Task #" << task id . << " " << =
 if res (
 logxx endl ::
 std this_thread :: sleep_for std chrono :: seconds waitOnEndTask ( :: ( ::
 std this_thread :: sleep_for std chrono :: seconds waitOnNullTask ( :: ( ::
